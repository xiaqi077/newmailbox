"""
认证相关 API 路由
"""
from datetime import timedelta, datetime
from typing import Optional, Any

from fastapi import APIRouter, Depends, HTTPException, status, Body, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel, ConfigDict, field_validator
import httpx # 新增引用

from app.core.config import settings
from app.core.database import get_db
from app.core.security import (
    verify_password,
    get_password_hash,
    create_access_token,
    create_refresh_token,
    decode_token
)
from app.models.user import User
from app.api.deps import get_current_user  # 从 deps 引入

router = APIRouter()

# Schema 定义
class LoginRequest(BaseModel):
    username: str
    password: str
class RegisterSchema(BaseModel):
    model_config = ConfigDict(extra="ignore")

    username: str
    email: str  # 改为普通 str，不使用 EmailStr
    password: str
    full_name: Optional[str] = None
    password_confirm: Optional[str] = None

    @field_validator("password_confirm")
    @classmethod
    def validate_password_confirm(cls, v: str, info: Any) -> str:
        if "password" in info.data and v != info.data["password"]:
            raise ValueError("两次输入的密码不一致")
        return v

class LoginSchema(BaseModel):
    username: str
    password: str


class ChangePasswordSchema(BaseModel):
    old_password: str
    new_password: str

class UpdateProfileSchema(BaseModel):
    username: Optional[str] = None
    email: Optional[str] = None
    full_name: Optional[str] = None
    avatar_url: Optional[str] = None

class MicrosoftExchangeSchema(BaseModel):
    code: str
    client_id: str
    client_secret: str
    redirect_uri: str

@router.post("/microsoft/exchange", summary="Exchange Microsoft Code for Tokens")
async def exchange_microsoft_token(payload: MicrosoftExchangeSchema):
    """交换微软授权码获取 Token"""
    token_url = "https://login.microsoftonline.com/common/oauth2/v2.0/token"
    data = {
        "client_id": payload.client_id,
        "client_secret": payload.client_secret,
        "code": payload.code,
        "redirect_uri": payload.redirect_uri,
        "grant_type": "authorization_code"
    }
    
    async with httpx.AsyncClient() as client:
        try:
            resp = await client.post(token_url, data=data)
            if resp.status_code != 200:
                # 尝试解析错误信息
                error_detail = resp.text
                try:
                    error_json = resp.json()
                    error_detail = error_json.get("error_description", error_detail)
                except (ValueError, KeyError):
                    pass
                raise HTTPException(status_code=400, detail=f"Microsoft Auth Failed: {error_detail}")
            return resp.json()
        except httpx.RequestError as e:
            raise HTTPException(status_code=500, detail=f"Network Error: {str(e)}")

@router.post("/login", summary="用户登录")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    """OAuth2 兼容的登录接口"""
    # 查找用户（支持用户名或邮箱登录）
    result = await db.execute(
        select(User).where(
            (User.username == username) | 
            (User.email == username)
        )
    )
    user = result.scalar_one_or_none()
    
    # 验证用户和密码
    if not user or not verify_password(password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="用户账号已被禁用"
        )
    
    # 更新最后登录时间
    user.last_login_at = datetime.utcnow()
    await db.commit()
    
    # 创建访问令牌和刷新令牌
    access_token_expires = timedelta(minutes=settings.access_token_expire_minutes)
    access_token = create_access_token(
        subject=user.email, # 注意：这里用 email 作为 subject，与 deps.py 对应
        expires_delta=access_token_expires
    )
    refresh_token = create_refresh_token(subject=user.email)
    
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": settings.access_token_expire_minutes * 60,
        "user": user.to_dict()
    }

@router.post("/register", summary="用户注册")
async def register(
    payload: RegisterSchema,
    db: AsyncSession = Depends(get_db)
):
    """用户注册接口"""
    # 检查用户名是否已存在
    result = await db.execute(select(User).where(User.username == payload.username))
    if result.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="用户名已被使用"
        )
    
    # 检查邮箱是否已存在
    result = await db.execute(select(User).where(User.email == payload.email))
    if result.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="邮箱已被注册"
        )
    
    # 创建新用户
    hashed_password = get_password_hash(payload.password)
    new_user = User(
        username=payload.username,
        email=payload.email,
        hashed_password=hashed_password,
        full_name=payload.full_name,
        is_active=True,
        is_superuser=False
    )
    
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    
    return {
        "success": True,
        "data": new_user.to_dict()
    }

@router.post("/logout", summary="用户登出")
async def logout(current_user: User = Depends(get_current_user)):
    """用户登出接口"""
    return {"message": "登出成功"}

@router.get("/me", summary="获取当前用户信息")
async def get_me(current_user: User = Depends(get_current_user)):
    """获取当前登录用户的信息"""
    return current_user.to_dict()

@router.post("/refresh", summary="刷新访问令牌")
async def refresh_token(
    refresh_token: str = Body(..., embed=True),
    db: AsyncSession = Depends(get_db)
):
    """使用刷新令牌获取新的访问令牌"""
    payload = decode_token(refresh_token)
    
    if payload is None or payload.get("type") != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的刷新令牌",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    email = payload.get("sub")
    if email is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的刷新令牌"
        )
    
    # 验证用户是否存在且活跃
    result = await db.execute(select(User).where(User.email == email))
    user = result.scalar_one_or_none()
    
    if user is None or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户不存在或已被禁用"
        )
    
    # 生成新的访问令牌
    access_token_expires = timedelta(minutes=settings.access_token_expire_minutes)
    access_token = create_access_token(
        subject=user.email, 
        expires_delta=access_token_expires
    )
    new_refresh_token = create_refresh_token(subject=user.email)
    
    return {
        "access_token": access_token,
        "refresh_token": new_refresh_token,
        "token_type": "bearer",
        "expires_in": settings.access_token_expire_minutes * 60
    }

@router.patch("/profile", summary="更新用户资料")
async def update_profile(
    payload: UpdateProfileSchema,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """更新当前用户的资料"""
    if payload.username is not None and payload.username != current_user.username:
        # 检查用户名是否已存在
        result = await db.execute(select(User).where(User.username == payload.username))
        if result.scalar_one_or_none():
            raise HTTPException(status_code=400, detail="用户名已被使用")
        current_user.username = payload.username
    
    if payload.email is not None and payload.email != current_user.email:
        # 检查邮箱是否已存在
        result = await db.execute(select(User).where(User.email == payload.email))
        if result.scalar_one_or_none():
            raise HTTPException(status_code=400, detail="邮箱已被注册")
        current_user.email = payload.email

    if payload.full_name is not None:
        current_user.full_name = payload.full_name
    if payload.avatar_url is not None:
        current_user.avatar_url = payload.avatar_url
    
    await db.commit()
    await db.refresh(current_user)
    
    return current_user.to_dict()

@router.post("/change-password", summary="修改密码")
async def change_password(
    payload: ChangePasswordSchema,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """修改当前用户的密码"""
    # 验证旧密码
    if not verify_password(payload.old_password, current_user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="原密码错误"
        )
    
    # 更新密码
    current_user.hashed_password = get_password_hash(payload.new_password)
    current_user.must_change_password = False
    await db.commit()
    
    return {"success": True, "message": "密码修改成功"}
